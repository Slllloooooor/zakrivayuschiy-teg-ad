# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Обзор проекта

Статичный веб-сайт "Закрывающий тег" - учебный проект Яндекс Практикума, сфокусированный на HTML/CSS верстке и анимациях с использованием vanilla JavaScript.

## Архитектура

Проект использует модульную CSS архитектуру с разделением ответственности:

- **styles/globals.css** - CSS reset и базовые стили (box-sizing, сброс отступов, утилита visually-hidden)
- **styles/variables.css** - CSS кастомные свойства для темизации и адаптивных значений
- **styles/style.css** - Основные стили компонентов
- **styles/animations.css** - Keyframe анимации и классы анимаций
- **fonts/fonts.css** - Объявления @font-face

Все стили загружаются в определенном порядке в index.html для правильного каскада.

## Критичные имена CSS классов

Функционал кнопки лайка зависит от конкретных имен классов, которые **нельзя изменять**:

- `like-icon` - SVG иконка анимированного сердца
- `card__like-button` - Кнопка Like рядом с иконкой
- `card__icon-button` - Кнопка, оборачивающая иконку
- `is-liked` - Класс состояния для лайкнутой иконки
- `button__text` - Текстовый элемент внутри кнопки

Эти классы жестко прописаны в scripts/like.js и используются в styles/style.css и styles/animations.css. Переименование сломает функциональность лайков.

## Реализация кнопки лайка

Система лайков (scripts/like.js) использует:
- `toggleIsLiked()` - Переключает класс `is-liked` на иконке сердца
- `setButtonText()` - Меняет текст кнопки между "Like" и "Unlike" с задержкой 500мс для синхронизации с анимацией

Скрипт находит все кнопки лайков при загрузке страницы и назначает обработчики клика на иконку и кнопку.

## Тестирование и CI/CD

- **Автоматические тесты** запускаются через GitHub Actions (.github/workflows/tests.yml)
- Тесты используют кастомный экшен Яндекс Практикума: `Yandex-Practicum/test-project-action@v1` с project ID `zakrivayuschiy-teg-ad`
- Тесты работают только на публичных репозиториях (падают, если репозиторий приватный)
- Тесты запускаются на все пуши в любые ветки и теги

## Команды для разработки

Это статичный HTML/CSS/JS проект без системы сборки и package.json.

Для разработки:
- Открыть `index.html` напрямую в браузере, или
- Использовать любой локальный dev-сервер (например, `python -m http.server`, VS Code Live Server и т.д.)

В репозитории не определены команды для сборки, линтинга или тестирования.

## Шрифты

Проект использует два шрифта:
- **Inter Variable** (Inter-Variable.woff2) - Вариативный шрифт, требующий особой настройки @font-face
- **Press Start 2P** (PressStart2P-Regular.woff) - Пиксельный шрифт

## Проектная работа «Закрывающий тег»

Проектная работа «Закрывающий тег»
Добро пожаловать в последний проект модулей вёрстки!
Учиться сложно, но вы шаг за шагом продвигаетесь по желаемому пути — это заслуживает восхищения. Раз вы читаете этот текст, то уже преодолели многое, получили новые знания и навыки.
В этой работе мы просим вас вспомнить и отрефлексировать пройденный к этому моменту путь, посмотреть на своё состояние и эмоции на разных этапах учёбы.

Как обычно, в последнем уроке темы, «Сдача проектной работы», к вам в аккаунт GitHub автоматически скопируется стартовый репозиторий. Ознакомьтесь с описанием, чек-листом и получите заготовку. Потом вернитесь к этому уроку и приступайте к выполнению.
Желаем удачи!
В этом проекте вы сначала поработаете над статичной версией, потом над адаптивом и в самом конце разберётесь с анимацией. Напомним, что такой подход помогает воспринимать проект как единое целое, а не как совокупность отдельных частей.
Шаг 1. Настройка проекта
Откройте макет проекта «Закрывающий тег».
Скачайте из Figma необходимые изображения и SVG-файлы. Оптимизируйте их: задайте фавиконам нужные размеры и форматы, разложите всё по папкам проекта. Не скачивайте иконку с сердцем, её нужно использовать иначе.
Превратите SVG с изображением дискеты в symbol. Вам нужно будет использовать эту иконку так.
Добавьте в проект фавикон и иконку для смартфонов.
Шаг 2. Работа над статичной версией
1. Включите и настройте шрифты
   В архиве два шрифта — PressStart2P и Inter. Шрифт Inter вариативный, к нему особое внимание.
   Опишите в файле fonts/fonts.css подключение обоих шрифтов. Подключая вариативный Inter, перечислите те веса шрифта, которые используются в макете, в виде диапазона.
   Задайте две переменные с именами этих шрифтов в файле styles/variables.css. Одну — для основного шрифта Inter, а другую — для акцентного PressStart2P.
   Основной шрифт можете смело применить к селектору .page, сославшись на переменную. Только не забудьте указать альтернативный системный шрифт.
   Настройте вес вариативного шрифта. Удобно вынести в переменные толщину основного текста карточки и толщину заголовка карточки.
   Основной вес шрифта применяйте к селектору .page через font-variation-settings.
   Все переменные должны лежать только в файле variables.css.
2. Доработайте шапку
   Секция резиновая по ширине, используйте clamp или относительные единицы, а на мобильном устройстве — растяните секцию на всю ширину. Для реализации этой ширины удобно внедрить дополнительный класс, а размер вынести в переменную.
   Другие резиновые элементы — логотип, заголовок, отступы в шапке. Используйте clamp.
   Чтобы браузер не воспринимал как теги символы < и >, используйте HTML-мнемоники &lt; и &gt;.
3. Добавьте основной контент
   Рекомендуем сначала создать одну карточку:
   По ширине секции с контентом (карточек) тоже резиновые, используйте clamp или относительные единицы, а на мобильном устройстве — растяните их на всю ширину. Как и в шапке, для реализации этой ширины удобно создать дополнительный класс, а размер вынести в переменную.
   Иконку с сердцем поместите внутрь тега <button>. Обратите внимание на комментарии в прекоде, там описано, какие классы задать иконке. Если класс будет не тот, лайкнуть иконку не получится.
   Содержимое кнопок «Like» и «Сохранить на память» поместите в <span> с отдельным классом button__text. Это поможет делать необходимые анимации.
   Для иконки внутри кнопки «Сохранить на память» используйте тег use и опишите в SVG-файле symbol, а вот иконку сердца придётся вставить в код инлайново. Подробнее об этом в шаге с анимациями. На стадии вёрстки лейаута просто вставьте туда нужную SVG-иконку, чтобы прийти к неанимированному, похожему на макет результату. В Фигме эта иконка лежит отдельно от остальных, используйте её на этапе построения лейаута.

Все состояния интерактивных элементов — ховеры и фокусы — оставьте на потом, их удобнее реализовывать вместе с анимациями.
4. Добавьте лейблы на карточки
   Поверх каждой карточки должен появиться лейбл:

Создайте обёртку для изображения. В этом контейнере будет лежать изображение и текстовый элемент.
Спозиционируйте лейбл.
Добейтесь нужного визуального эффекта с помощью режима смешивания hard-light.
Обратите внимание на обводку текста. В этом спринте вы изучали, как делать такие обводки. Не забудьте проверить поддержку нужного свойства через @supports и сделать фоллбэк в виде text-shadow. Цвет обводки храните в отдельной переменной.
Шаг 3. Ваш контент
Теперь сделайте восемь одинаковых карточек, добавьте к ним нужные отступы и вставьте в каждую тексты из макета.
Время для творчества. Подберите картинки в каждую из восьми карточек и напишите немного личного текста вместо текста: Место для .... Подумайте о том пути, который уже прошли, о трудностях, с которыми справились. Нам будет очень интересно прочитать ваши мысли. Будет здорово, если вы поделитесь фотографиями из личного архива или подберёте что-то по настроению на Unsplash или Giphy. Не сдерживайте себя!
Вместо лейблов внутри карточки подберите одно или два слова, которыми можете охарактеризовать своё состояние в каждой из описанных точек курса.
Шаг 4. Всплывающее окно
Кнопка «Сохранить на память» должна вызывать модальное окно. Реализуйте эту механику с помощью изученного в этом спринте элемента dialog. При вёрстке содержимого окна используйте повторно изображение дискеты и стили кнопок во всем макете.
Чтобы сверстать две колонки внутри модального окна, вы, скорее всего, захотите изменить в нём значение display. Воздействие на display повлияет на возможности скрывать и показывать модальное окно, ведь по умолчанию у элемента dialog предустановленное значение display.
Чтобы избежать этой проблемы, меняйте свойство display у диалога только в состоянии opened. Не забудьте также стилизовать задний слой у открытого модального окна. Для этого придуман псевдоэлемент backdrop. Закрываться модальное окно должно по кнопке Ок.
Шаг 5. Адаптивность
Используйте медиазапрос для экранов меньше 375 px. Должно хватить такого варианта: @media (width <= 375px).
Скорректируйте правила для нужных элементов согласно макету. Стилей там переопределено совсем немного. Макет практически целиком резиновый.
Шаг 6. Фильтры
Карточки
На каждое из изображений добавьте дополнительный уникальный класс и стилизуйте CSS-фильтром, который ещё сильнее подчеркнёт ваш замысел и передаст нужную эмоцию. Минимум на семи картинках должны быть разные фильтры и хотя бы один из них — множественный.
Фон
Значение для свойства background-image лучше хранить в отдельной переменной. Фон фиксирован, скроллится со всей страницей.
Фон должен постепенно увеличивать плотность цвета сверху вниз, поэтому нужно создать сложный и множественный градиент:
Первый градиент должен создавать повторяющиеся полоски слева направо, шириной в 2px:
одна полоска цветом #d3d3d3;
другая — прозрачная, такого же размера.
Вспомните про repeating-linear-gradient, именно он вам нужен.
Второму градиенту задайте такие же настройки из полос, но направление его должно идти сверху вниз. У вас получится своеобразная сетка из цветных и прозрачных линий.
В третьем градиенте цвет должен равномерно меняться сверху вниз — от #e7e7e7 к #1a1a1a.
Именно последний градиент создаст эффект изменения насыщенности цвета. Мы немного продлили воздействие самого светлого оттенка и начали менять цвет от 0.01% всей высоты градиента, чтобы усилить эффект.
Чтобы такой фон из градиентов занимал всё пространство страницы, присвойте ему размер cover.
Шаг 7. Эффекты кнопок
Эффекты на кнопках при фокусе и ховере имеют разную плавность. Кроме того, эффекты кнопок «Like» и «Сохранить на память» отличается от эффекта кнопки, оборачивающей сердечко.
Кнопки «Like», «Сохранить на память» и «ОК»
Сначала разберёмся с фокусами.
В состоянии focus отмените стандартную обводку и добавьте тень блока. Нужная тень сдвинута на два пикселя по осям X и Y, с нулевым размытием, акцентного цвета.
Для box-shadow задайте настройки плавности 0.3s ease.
По наведению на кнопку должен плавно слева направо появляться псевдоэлемент. Добиться этого можно двумя путями:
через scale от 0 до 1;
через translate от -100% по оси X до 0. В этом случае кнопке придётся задать overflow.

Плавность здесь — 0.5s ease-in-out.
Хочется, чтобы текст перекрашивался постепенно: когда псевдоэлемент перекрывает его часть — меняется только эта часть текста. Поможет режим смешивания difference. Но придётся правильно подобрать цвета.
Чтобы текст оказался выше псевдоэлемента, сделайте вложенный в кнопку span относительно спозиционированным и при необходимости задайте z-index.
Напишите белый текст на белом фоне, режим смешивания поменяет белый цвет на противоположный — чёрный. А когда псевдоэлемент начнёт «наезжать» своим чёрным фоном, режим смешивания будет менять надпись на белую.
Для хранения цвета текста используйте переменные. В одной из кнопок у вас лежит иконка дискеты. Не забудьте применить режим смешивания и к ней.
Фокус на кнопке с сердцем
Для кнопки, оборачивающей сердце, описан только фокус. Все остальные состояния будут производиться на самой иконке внутри.
В состоянии focus-visible у кнопки появляется рамка — сплошная линия акцентного цвета шириной два пикселя. Не забудьте убрать обводку у состояния focus. Граница должна появляться плавно: 0.3s ease. А высота блока должна быть такой же, как у кнопки справа. Проследите за размерами.
Скорее всего, вам понадобится задать прозрачную границу у элементов без фокуса и менять только цвет границы у элемента в фокусе.
Шаг 8. Анимация иконки сердца
Подготовка SVG
Чтобы разобраться с анимацией сердца, нужно внимательно посмотреть на структуру его SVG-кода и даже немного подредактировать его.
Посмотрим в Фигме:
Сердцевина, основное тело, контур и искры вокруг дизайнер разложил на отдельные слои. Часто в рабочей ситуации всё не так удобно, приходится самим выискивать кривые через инструменты разработчика и раскладывать их по нужным слоям.
Если скачать или скопировать SVG-код фрейма «heart in paths», увидим внутри тега svg четыре тега path и некоторый мусор. Его нужно почистить перед дальнейшей работой.
Замените кодом без всего лишнего ту иконку, которую использовали до этого. Не забудьте добавить этому SVG класс like-icon.
Все будущие анимации строятся на том, чтобы перекрашивать или масштабировать разные path в этом SVG, поэтому следующим этапом каждый path хорошо бы назвать своим именем класса.
Удобно смотреть на кривые через инструменты разработчика, чтобы понять, какая за что отвечает, и назвать их. Мы выбрали такие имена классов и дальше будем пользоваться ими:
core — сердцевина;
contour — контур;
main-body — основное тело сердца;
sparks — искры вокруг.
Ещё в рамках одной из анимаций вам нужно будет увеличить всё сердце, но без искр. Поэтому лучше объединить core, contour и main-body в группу с классом heart, для этого используйте контейнер <g></g>.
Внутри видимой в исходном состоянии группы с сердцем должен остаться только контур. Поэтому замените значения цветов в атрибутах везде, кроме контура, на none.
Получится так:

Цвет контура выносите в переменную. Вы можете указывать ссылку на переменную прямо в атрибуте fill. Вот так: fill="var(--name)".
Удобно, когда все нужные цвета лежат в переменных. Одна у вас уже есть — контур сердца, например --contour-color.
Второй переменной будет цвет заливки, например --animation-fill-color. Он красный. Задайте такую переменную и укажите в качестве значения fill для искр.
Мы могли бы скрыть искры, указав fill: none;, это тоже хороший подход, но предпочли скрыть их через opacity в CSS.
Подходы равноценны, но нам показалось, что в приведённых анимациях смысл в том, чтобы искры появлялись, становились видимыми, а не приобретали цвет. На самом деле не имеет значения, как именно скрыть искры.
Вот результат, который у вас должен получиться. Сердцевина и основное тело не залиты цветом, заливка контура ссылается на переменную, заливка искр ссылается на переменную, искрам задана прозрачность в CSS.

Шаг 9. Анимация сердца
Сердце анимируется в трёх состояниях: при ховере (и наоборот, когда уводим курсор), при нажатии и удержании (в состоянии :active), при клике.
Для реализации придётся написать достаточно много кода. Рекомендуем вынести цвета контура и заливки в отдельные переменные.
Состояние :hover
При наведении на иконку сначала закрашивается акцентным цветом сердцевина, а потом основное тело. Все анимации на ховере производятся последовательно, а вот с длительностью и задержкой нужно разбираться отдельно.
Для этой анимации не нужны кейфреймы. Просто опишите плавность изменения значения fill для нужных элементов иконки. Меняйте значение у сердцевины сразу же при наведении мышки и в течение 0.3s. А в обратной ситуации, когда курсор уходит, — с задержкой в 0.03s, ведь вам нужно будет дождаться, когда потухнет основное тело.
Временные интервалы будут идти немного внахлёст, это создаст нужное ощущение плавности. Основное тело сердца при наведении курсора перекрашивайте с задержкой в 0.05s в течение 0.3s. А когда курсор уходит с сердца, основное тело, наоборот, становится прозрачным без задержек и перекрашивается всё те же 0.3s.
Обратите внимание, что вся заливка при наведении происходит цветом контура.
Состояние :active
При нажатии и удержании кнопки мышки сердцевина и основное тело сердца закрашиваются основным цветом анимации — красным. Контур не перекрашивается. Когда вы отпускаете кнопку, происходит клик, но это уже другая анимация.
Чтобы добиться такого эффекта при зажатии, вам нужно прописать абсолютно такие же настройки transition, как и для эффекта по наведению, но поменять цвет на красный.
Клик по иконке
Как только по иконке происходит клик, скрипт добавляет в код иконки дополнительный класс is-liked, а при повторном клике убирает его. Это позволит вам создавать селекторы вроде .like-icon.is-liked .contour и описать анимацию для них.
Вот что происходит при клике:
Закрашивается сердцевина.
С небольшой задержкой закрашивается основное тело.
Ещё с большей задержкой закрашивается контур.
Происходит небольшое масштабирование сердца и возврат к исходному масштабу.
Становятся видимыми и пропадают искры.

Цвет заливки во всех случаях красный. А время задержек не описывает завершение предыдущего шага. Мы всего лишь начинаем анимации чуть позже, чтобы каждая из них пришла в финальное состояние уже после завершения предыдущей. Так получается визуальная плавность.
Вот замедленное покадровое видео, на нём легче рассмотреть детали.
Перекрашивать сердцевину и основное тело вы уже умеете. Абсолютно те же параметры, что и при состоянии active. После этого с небольшой задержкой в 0.06s перекрашивайте контур. Длительность всех анимаций — 0.3s.
Чтобы масштабировать сердце и сделать вспышку искр, придётся написать два кейфрейма:
Масштабирование с 1 до 1.25. Эту анимацию нужно запустить на всей группе элементов .heart через 0.1s после появления класса is-liked в разметке. Масштабирование должно длиться 0.3s с плавностью ease-in, происходить однократно.
Кейфрейм для искр — изменение прозрачности или заливки (как вам удобно). Эта анимация длится 0.3s  и запускается через 0.3s, однократно, с плавностью ease-in.
Последний штрих — предусмотреть перекрашивание контура обратно, когда сердечко выключат. Контур лучше возвращать на место побыстрее — линейно, за 0.1s, без задержек.
Шаг 10. Публикация сайта
Когда всё будет готово, опубликуйте сайт на GitHub.
Инструкция
Зайдите в настройки Settings вашего проекта на GitHub.

В левой панели перейдите во вкладку Pages.

В выпадающем списке Branсh, выберите ту ветку, в которой работали, и нажмите Save.

Через какое-то время GitHub опубликует ваш сайт, а рядом с этим блоком появится ссылка на него. Добавьте ссылку на опубликованный сайт в файл README.md.
Если ссылка не откроется, напишите в конце адреса /index.html. Иногда требуется показать более явно, какую страницу открыть.


## Чек-лист проектной работы «Закрывающий тег. Финал»
Здесь вы найдёте критерии, которым должна соответствовать работа, а также общие рекомендации — их нужно учесть, чтобы выявить и самостоятельно исправить частые ошибки.
Отображение в браузере
Есть все секции, блоки и элементы макета, и они корректно отображаются в Firefox, Google Chrome и Яндекс Браузере.
Проект визуально соответствует макету на всех заданных размерах экрана:
отличие не более 10% при проверке системой скриншот-проверки автотестов;
отличие не более 5px по вертикали и 3px по горизонтали при проверке ревьюером.
Рекомендуем пользоваться плагином Pixel Perfect для доводки вёрстки.
Сетка макета не сбивается и вёрстка не «ломается» между брейкпоинтами, например:
при сжатии страницы сохраняется расположение элементов относительно друг друга на странице;
содержимое не выпадает за пределы своего блока;
блоки не наезжают друг на друга;
изображения не искажаются и выглядят так же, как в макете, на всех размерах экрана.
На всех размерах экрана, в том числе между брейкпоинтами, страница не прокручивается по горизонтали. Не появляется лишних полос прокрутки при ширине экрана, которая больше или равна минимально допустимой.
Свёрстаны все состояния элементов страницы, описанные в рекомендациях и макете.
Рекомендации к текущему проекту
Растровые изображения используются только для иллюстрации карточек и иконки для смартфона.
Правильно используется вариативный шрифт:
на сайте два шрифта: Inter — вариативный, PPressStart2P — нет;
при подключении вариативного шрифта указаны верные форматы: как обновленный woff2 supports variations, так и устаревающий woff2-variations;
вариативному шрифту заданы в виде диапазона при импорте все начертания, необходимые в будущем при вёрстке.
настройки вариативных шрифтов указаны в свойстве font-variation-settings.
На сайте фиксированное фоновое изображение:
фон реализован через background-color и background-image в CSS;
градиенты фона реализованы корректно, есть визуальный эффект затемнения нижней части.
применено свойство background-attachment: fixed для фиксации фонового паттерна при прокрутке страницы.
Только SVG с сердцем — иконки, с именованными через классы группами и path внутри вставлены инлайново (необходимо для анимации), остальные — через symbol + use. Паттерн на фоне — фоновое изображение.
На странице отображается не менее восьми карточек:
в каждой карточке отображается лейбл, выполненный с mix-blend-mode и text-stroke. Поддержка text-stroke и -webkit-text-stroke проверена директивой @supports. В случае, когда браузер не поддерживает ни одно из свойств, сработает колбэк в виде text-shadow.
картинки карточек стилизованы CSS-фильтрами, минимум на семи картинках разные фильтры, хотя бы один фильтр множественный.
Правильно используются трансформации и анимации:
присутствуют все анимации описанные в брифе проекта;
все изменения плавные;
при описании любой плавности описаны конкретные изменяемые свойства, отсутствует применение плавности для всех элементов сразу;
ни одна анимация или трансформация не приводит к тому, что один элемент не перекрывает другой элемент;
у всех кнопок анимация и изменения цветов текста определены свойством mix-blend-mode. Плавно перекрашиваются и цвет текста, и цвет иконки внутри кнопки.
Правильно реализовано модальное окно на странице:
появляется при клике на кнопку «Сохранить на память»;
сделано с помощью элемента dialog;
фон страницы при открытии модального окна стилизован через псевдоэлемент ::backdrop;
в вёрстке модального окна переиспользуются стили кнопки и иконка;
при нажатии на кнопку внутри модального окна оно закрывается.
Все интерактивные элементы имеют состояния hover и focus-visible.
Проект опубликован на GitHub Pages.
Структура проекта
В проекте отсутствуют пустые файлы.
Есть файл index.html .
Файловая структура проекта единообразна. Например: стили находятся в папке styles, картинки в папке images, шрифты в папке fonts, аналогично для других типов файлов.
HTML
Аккуратная разметка HTML. Предлагаем использовать Prettier для автоформатирования кода.
Валидный HTML, например:
нет незакрытых тегов, которые нужно закрывать;
списки свёрстаны правильно, внутри тегов списка находятся только пункты списка;
нет ошибок вложенности.
Валидность HTML можно проверить в этом валидаторе.
Стили подключены в правильном порядке: сначала шрифты, затем глобальные стили, затем собственные.
Язык страницы указан корректно.
Задано подходящее значение title.
Используется семантическая разметка:
теги <header> , <main> , <footer> , <section> , <nav> использованы по назначению, ими выделены соответствующие секции страницы;
для вёрстки заголовков применяются теги от <h1> до <h6>, текстовые блоки размечены тегами <p>, списки — <ul> и <li>;
есть многоуровневость заголовков;
есть единственный заголовок первого уровня;
для блоков, содержащих информацию, используются соответствующие ей смысловые семантические теги, например <article>, <address>, <time> или другие при необходимости;
ссылки на номер телефона и почту, если они есть на странице, снабжены префиксами в значении атрибутов href.
Для обозначения абзаца не используется тег переноса строки.
У всех изображений задан атрибут alt с описанием на языке страницы.
CSS
Аккуратное форматирование кода:
между селекторами и открывающими скобками стоит пробел;
каждое правило начинается с новой строки;
стоят точки с запятой;
закрывающие скобки вынесены на отдельную строку.
Соблюдены требования к именованию CSS-классов:
для CSS-классов выбраны подходящие по смыслу имена;
отсутствует слитное написание слов в именах классов;
единообразное разделение слов в именах CSS-классов во всём проекте, например, используется только kebab-case — разделение слов знаком -, или camelCase — разделение слов регистром символов;
в именах не используются транслитерация и сокращения, которые не являются общеупотребимыми.
в именах не используется привязка к числительным.
именования не должны противоречить позиции сущности на странице.
Если в брифе к проекту описаны имена классов, то старайтесь использовать их.
У body и типовых элементов сбрасываются браузерные отступы.
Для всех элементов сайта корректно заданы:
цвета фона;
размеры;
межстрочные расстояния;
межбуквенные расстояния и расстояния между словами при необходимости.
Корректно используются шрифты:
разные форматы шрифтов подключаются в правильном порядке — от самых современных к более старым с указанием формата как свойства CSS;
указаны альтернативные шрифты;
семейство, вес, начертание и размеры шрифтов во всех элементах страницы соответствуют заданным в макете.
Правильно организован лейаут страницы:
для организации лейаута ключевых блоков использован flex или grid;
корректно отцентрированы необходимые элементы на странице;
не задана фиксированная высота и ширина элементов там, где их можно не использовать или применены минимальные или максимальные значения. Блок растягивается, если в него вставлено в два-три раза больше контента;
абсолютное позиционирование используется только там, где нельзя применить статичное или относительное позиционирование;
контекст позиционирования указан корректно (например, position: relative у нужного элемента);
абсолютное позиционирование не применяется для динамического контента;
элементы спозиционированные абсолютно выравниваются минимум одной координатой;
корректно задано свойство z-index, нет спрятавшихся элементов;
при увеличении количества карточек направления сетки сохраняются корректными;
при увеличении количества параграфов в карточках — отступы между параграфами сохраняются;
Корректно реализована адаптивная вёрстка:
установлена максимальная и минимальная ширина контента в соответствии с макетом;
брейкпоинты сгруппированы. Если два брейкпоинта имеют небольшую пиксельную разницу в медиаправиле, они объединены в один;
между брейкпоинтами используется «резиновая» вёрстка;
правильно определены «резиновые» и статические размеры;
одинаковые свойства в разных медиаправилах не дублируются.
Нет пустых CSS-правил.
Нет дублирующихся селекторов.
Нет дублирующихся свойств внутри CSS-правил.
CSS-переменные корректно заданы и переопределены, используются запасные значения и имеются информативные названия.
Стили одинаковых элементов не дублируются, а переиспользуются.
Не используются инлайновые стили в HTML.
Правильно используются трансформации и анимации:
присутствуют все анимации, описанные в брифе проекта;
все изменения плавные;
при описании любой плавности описаны конкретные изменяемые свойства, отсутствует применение плавности для всех элементов сразу;
ни одна анимация или трансформация не приводит к тому, что ни один элемент не перекрывает другой элемент.
Все интерактивные элементы имеют состояния hover и focus-visible.
Хорошие практики
В этом списке собраны приёмы, которые помогут сделать проект ещё лучше.
На данном этапе их использовать необязательно — автотесты и ревьюер примут работу без них.
Однако такие хорошие практики помогут вам сделать портфолио более профессиональным. Опытные верстальщики обратят на них внимание.
В разметке нет лишних обёрток <div> у элементов.
В разметке у ссылок нет пустых атрибутов href.
Всем изображениям заданы ограничения размеров.
Для изображений настроена «ленивая» загрузка.
Элементам не добавлены классы, которые не используются.
В стилях не указаны неработающие свойства (например, не заданы размеры строчных элементов).
Для всех элементов на странице переопределено дефолтное значение свойства box-sizing.
При организации внутренней геометрии блоков внутренние отступы задаются через padding.
Нет лишних отступов у первых и последних элементов в списках и блоках с абзацами.
Раскладки flex или grid не применяются без необходимости там, где можно обойтись дефолтным отображением.
Для задания отступов между элементами flex и grid блоков использован gap вместо margin.
Нет чрезмерной стилизации. Например, одинаковые размеры прописаны и для обёртки, и для изображения внутри.
Интерлиньяж задан в относительных единицах измерения.
В элементах формы при необходимости используются inherit или currentColor.
Для предсказуемого поведения инпутов в разных браузерах использован appearance: none;.
Вместо overflow: scroll использован overflow: auto, чтобы не отображался ненужный скролл.
Вид курсора меняется при наведении на интерактивные элементы.
Для наилучшего позиционирования изображения при задании свойства object-fit задаётся также подходящее значение свойства object-position.
Для стилизации интерактивных элементов используется outline, а не border (outline не влияет на размеры элемента в потоке).
CSS-правила в коде расположены в примерном соответствии с позицией элементов в разметке.
Для стилизации используются только селекторы классов, псевдоэлементов и псевдоклассов, если речь не идёт о сбросе браузерных дефолтных стилей.
Вместо физических CSS-свойств используются логические CSS-свойства; единообразие в типе свойств.
Для отправки декоративных линий и фонов назад используется z-index: -1 .
В медиавыражениях под ширину экрана используется современный синтаксис задания диапазонов.
Для реализации лейаута максимально используется сетка, построенная на grid, и её возможности.
Для создания декоративных элементов используются псевдоэлементы, а не дополнительные теги в разметке.
Для элементов разметки, не несущих смысловой нагрузки, задаётся атрибут aria-hidden="true" .
Ссылки на внешние ресурсы открываются в новом окне.
У ссылок сброшен outline в :focus и заданы стили :focus-visible.
Используются разные форматы и размеры изображений в элементе <picture>. 

